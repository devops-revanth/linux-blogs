---
title: "Chapter 6 : Understanding File Access Control in Linux: Permissions, Ownership & ACLs"
datePublished: Thu Apr 10 2025 02:11:06 GMT+0000 (Coordinated Universal Time)
cuid: cm9aq1sn1000r09l8biqk3744
slug: understanding-file-access-control-in-linux-permissions-ownership-and-acls

---

ğŸ‘‹ Hey Everyone!

Itâ€™s been **5 days** since I started writing blogs, and I hope I continue this journey consistently. If you have any feedback or suggestions, feel free to share â€” itâ€™ll help me grow and improve even more. ğŸ’¬ğŸ™

Now letâ€™s jump back into our Linux learning series! So far, weâ€™ve explored:

ğŸ“ File types  
ğŸ› ï¸ How to create files and directories  
ğŸ” How to search for files effectively

In todayâ€™s blog, weâ€™ll take things one step further by discussing **file permissions and ownership** â€” understanding **who** can do **what** with a file.

But before we go there, letâ€™s quickly address something weâ€™ve been seeing a lot

### ğŸ” How Do We See File Permissions in Linux?

If youâ€™ve been following along, you probably noticed that we often use:

```bash
ls -l
```

...to list files. But wait â€” what **exactly** is that `-l` doing?

Weâ€™ve been using it all along, but we **never really discussed the full syntax** of Linux commands! So before jumping into **file permissions and ownership**, letâ€™s understand whatâ€™s happening behind the scenes with that `-l`.

### ğŸ§¾ Linux Command Syntax

In Linux, commands generally follow this basic pattern:

```bash
command [option(s)] [argument(s)]
```

#### ğŸ”¹ Options:

* Modify the behavior of the command.
    
* Usually start with a hyphen (`-`) followed by one or more letters.
    
* Example: `-l` gives you a long listing format in `ls`.
    
* You can **combine options** together:  
    ğŸ‘‰ `ls -ltr` is the same as `ls -l -t -r`.
    

#### ğŸ”¹ Arguments:

* These are the targets the command operates on.
    
* They can be **files, directories, users**, etc.
    
* Some commands **require** arguments, while others have **defaults**.
    
* Example:
    
    ```bash
    ls -l raju
    ```
    
    You might see an output like this:
    
    ```bash
    -rw-r--r-- 1 revanth revanth 4096 Apr  9 18:00 raju
    ```
    
* In this case, `raju` is the **argument**. If a file or directory named `raju` exists, it will be listed in long format.
    

### ğŸ” Understanding File Permissions in Linux

Linux is a **multi-user operating system**, which means multiple users can work on the same machine at the same time. Naturally, this raises an important question:

> **How do you protect your files from being accessed or modified by others?**

Thatâ€™s where **file permissions** come into play. Just like you have the responsibility of safeguarding your system as a Linux admin, **each user is responsible for controlling access to their files and directories**.

---

### ğŸ›¡ï¸ Why Do We Use File Permissions?

Simple: **To protect your environment**.

Permissions help:

* Prevent unauthorized users from **viewing** your files.
    
* Stop others from **deleting or modifying** important directories or scripts.
    
* Ensure only the right users can **execute** programs.
    

### ğŸ”§ Viewing File Permissions

Permissions for a file or directory can be **viewed using**:

```bash
ls -l
```

As we saw earlier in the example of `ls -l raju`, the first part of the output tells us about permissions:

```bash
-rw-r--r-- 1 revanth revanth 4096 Apr  9 18:00 raju
```

That first section `-rw-r--r--` is the **permission string**, and hereâ€™s how it works:

---

### ğŸ“œ Types of Permissions

There are **3 types** of permissions in Linux:

| Symbol | Permission | Meaning |
| --- | --- | --- |
| `r` | Read | View the contents of a file or list a directory |
| `w` | Write | Modify the file or directory contents |
| `x` | Execute | Run a script/program (for files), or **enter** a directory (for directories) |

---

### ğŸ‘¥ Who Gets These Permissions?

Permissions can be set for **3 levels** of users:

| Symbol | Level | Who it refers to |
| --- | --- | --- |
| `u` | User | The **owner** of the file (you!) |
| `g` | Group | Users who belong to the same group |
| `o` | Others | All other users on the system |

**Example from earlier:**

### **\-rw-r--r--**

This means:

* **User (u):** rw- **â†’** **Read & Write**
    
* **Group (g):** r-- **â†’Read**
    
* **Others (o):** r-- **â†’ Read**
    

---

> ğŸ§  **Note:**  
> For **files**, `x` is needed to **execute** scripts/programs.  
> For **directories**, `x` is needed to **enter** the directory.

### ğŸ” Now That We Understand Permissionsâ€¦ How Do We Change Them?

Once you understand how file permissions work in Linux, the next step is learning **how to modify them** to control access effectively. And thatâ€™s where the `chmod` command comes in.

### ğŸ› ï¸ Command to Change File Permissions: `chmod`

If you ever get stuck, remember you can always refer to the manual:

```bash
man chmod
```

or

```bash
chmod --help
```

### âœ… Symbolic Mode â€“ Human Readable Way

In symbolic mode, you specify which permission (read, write, execute) you want to **add (+)** or **remove (â€“)** for a **user (u)**, **group (g)**, or **others (o)**.

Some examples:

```bash
chmod g+w raju       # Adds write permission to group
chmod u-w raju       # Removes write permission from user
chmod a-r raju       # Removes read permission from all (user, group, others)
chmod u+rw raju      # Adds read and write permission for the user
chmod g+rw raju      # Adds read and write permission for group
chmod o+r raju       # Adds read permission for others
```

---

### ğŸ”¢ Numeric (Octal) Mode â€“ Fast and Efficient

Each permission is assigned a numeric value:

* **Read (r) = 4**
    
* **Write (w) = 2**
    
* **Execute (x) = 1**
    

To set permissions using numbers, you **add the values** together:

| Permission | Value |
| --- | --- |
| r (Read) | 4 |
| w (Write) | 2 |
| x (Execute) | 1 |

Examples:

```bash
chmod 444 raju   # Read-only for everyone
chmod 644 raju   # rw for user, r for group and others
chmod 755 raju   # rwx for user, rx for group and others
```

ğŸ¯ Tip: The order always goes **User â†’ Group â†’ Others** in numeric format.

### ğŸ” Bonus: Recursive Permission Changes

Sometimes, you may want to apply permission or ownership changes **not just to a single file or directory**, but also to **all the files and subdirectories inside it**. This is where **recursive options** come into play.

### âœ… Recursive `chmod`

To change **permissions** for all files and directories inside a given directory:

```bash
chmod -R 755 /dir
```

* `-R` stands for **recursive**
    
* `755` gives:
    
    * User â†’ Read, write, execute
        
    * Group & Others â†’ Read, execute
        

This command will apply the same permission to **every file and subdirectory** within `/dir`.

### âš ï¸ Use with Caution!

Recursive commands affect **all content** under the specified path â€” so double-check before running them, especially with `sudo`!

### ğŸ§‘â€ğŸ’» File Ownership in Linux

In Linux, every file and directory has an **owner** and a **group** associated with it. Managing these properly is essential for ensuring proper access control and security.

---

#### ğŸ”§ Ownership Commands:

* `chown` â€“ Changes the **owner** (user) and/or **group** of a file or directory.
    
    > Only the **root** user can execute `chown`.
    
    ```bash
    sudo chown raju file.txt            # Change owner to 'raju'
    sudo chown raju:devops file.txt     # Change owner to 'raju' and group to 'devops'
    sudo chown -R raju:devops /project  # Recursively change ownership inside /project
    ```
    
* `chgrp` â€“ Changes the **group ownership** of a file or directory.
    
    ```bash
    chgrp devops file.txt               # Change group to 'devops'
    chgrp -R devops /project            # Recursively change group in /project
    ```
    

---

### âœ… Recursive `chown`

To change **ownership** of a directory and everything inside it:

```bash
chown -R username:groupname /dir
```

* `-R` again is **recursive**
    
* `username:groupname` is the new owner and group you're assigning
    

This is useful when moving project files between users or setting up shared directories.

### âš ï¸ Use with Caution!

Recursive commands affect **all content** under the specified path â€” so double-check before running them, especially with `sudo`!

### ğŸ“Œ Important Note: File Deletion â‰  File Ownership

A **user can delete a file even if they do not own it**, provided they have the correct permissions on the directory containing the file.

#### ğŸ“‚ Example Scenario:

* ğŸ‘¤ **User**: `raju`
    
* ğŸ“„ **File**: `/home/raju/test`
    
* ğŸ” **File Owner**: `root:root`
    
* ğŸ“ **File Permissions**: `-rw-r--r--`
    
* ğŸ“ **Directory**: `/home/raju`
    
* ğŸ”‘ **Directory Owner**: `raju`
    
* ğŸ”’ **Directory Permissions**: `rwx------`
    

Even though **Raju is not the owner** of the file (`test`), he **can delete it** because he has:

* **Write (w)** permission on the directory â€” allows modifying contents (like deleting files).
    
* **Execute (x)** permission on the directory â€” allows entering into the directory.
    

## ğŸ” Important Permission Rules in Linux

Understanding how permissions work is essential to secure your Linux system effectively. Here are **key rules** to remember when dealing with files and directories:

---

### âœ… To **Delete a File**:

A user needs:

* âœ… **Write (**`w`) permission on the directory (to modify directory contents)
    
* âœ… **Execute (**`x`) permission on the directory (to access the directory)
    

ğŸ“Œ **Note:** The permission on the file itself **doesnâ€™t matter** for deletion. It is the **directory's permissions** that control it.

---

### âœ… To **Read a File**:

A user must have:

* âœ… **Read (**`r`) permission **on the file itself**
    

---

## ğŸš« How to Prevent File Deletion by Others?

Here are some ways to **protect your files from being deleted**:

### ğŸ”¹ 1. Remove Write Permission on the Directory

```bash
chmod -w /home/raju
```

> âš ï¸ This prevents **file deletion** AND **file creation** in the directory.

---

### ğŸ”¹ 2. Use ACLs (Access Control Lists)

ACLs allow **fine-grained control** beyond standard permission bits.

```bash
setfacl -m u:username:--- /home/raju
```

---

### ğŸ”¹ 3. Move Files to a Secure Directory

Another safe option is to move sensitive files into a directory with **restricted access** (e.g., `700` permissions) where only the owner can access.

```bash
mkdir /secure
chmod 700 /secure
mv important_file.txt /secure/
```

## ğŸ”’ What is ACL (Access Control List)?

Think of **ACL** as an **additional security layer** that runs **on top of standard Linux file permissions**.

* It allows **more flexible** and **fine-grained** control over who can access files and directories.
    
* You can **assign permissions to specific users or groups**â€”even if they are **not the owner** or **part of the fileâ€™s group**.
    

---

### ğŸ“˜ Why Use ACL?

Letâ€™s say:

* A file is owned by `root`
    
* You want to allow **only one specific user** (not part of root group) to read that file.
    

You could use:

* `chmod o+r file` â†’ But this gives read access to **everyone** (not secure âŒ)
    

âœ… **With ACL**, you can allow **only that one user** to read the file, while keeping it restricted from others.

---

### ğŸ“Œ From Linux man pages:

> ACLs are used to define more **fine-grained discretionary access rights** for files and directories.

---

## ğŸ› ï¸ ACL Commands

### â• Add ACL Permission

```bash
# Give rwx permission to a user
setfacl -m u:john:rwx test

# Give read-write permission to a group
setfacl -m g:developers:rw test
```

### ğŸ” Recursive ACL (Inherit ACL from Directory)

```bash
setfacl -Rm u:john:rw /dir
```

### âŒ Remove Specific ACL Entry

```bash
setfacl -x u:john test
```

### ğŸ§¹ Remove All ACL Entries

```bash
setfacl -b test
```

---

## ğŸ“ How Do You Know ACL Is Set?

After assigning ACLs, you'll notice a `+` symbol at the end of the permission string when running `ls -l`.

### Example:

```bash
ls -l test
-rw-r--r--+ 1 root root 0 Apr 9 10:00 test
```

> That `+` indicates **ACL is active** on the file.

You can view ACL entries using:

```bash
getfacl test
```

---

### âš ï¸ Important Note

Even if a user has **write (**`w`) permission via ACL, they **still canâ€™t delete the file** unless they have write & execute permissions on the **directory** it resides in â€” same rule as standard permissions.

---

### ğŸ¯ Why ACL Was Introduced?

ACLs solve a simple but powerful problem:

> â€œI want to allow **only one user** (not everyone) to access a file they donâ€™t own.â€

ACL = **Permission precision without overexposure.**

### ğŸ”š Wrapping Up

In this blog, we explored the world of **Linux file permissions**, **ownership**, and the powerful concept of **ACLs**. We started with understanding how permissions are displayed using `ls -l`, broke down the meaning of `rwx`, and learned how to change permissions with `chmod` (both symbolic and numeric methods). We also discussed ownership with `chown` and `chgrp`, and finally touched on **Access Control Lists (ACLs)** for fine-grained permission control.

Key takeaways:

* Use `ls -l` to view file permissions.
    
* Change permissions using `chmod`, ownership using `chown`, and groups with `chgrp`.
    
* For advanced control, use ACLs via `setfacl` and `getfacl`.
    
* Donâ€™t forget the recursive power of `chmod -R` and `chown -R` when dealing with directories!
    

Understanding these fundamentals gives you more control, security, and confidence while working in any Linux environment â€” especially as an aspiring DevOps or Linux administrator.

### ğŸ™ Thank You & Keep Exploring

Thanks for sticking around till the end, If you liked this post or have any suggestions, feel free to drop a comment â€” every bit of feedback helps me grow and deliver even better content.

Until next timeâ€¦  
âœ¨ **Stay curious, keep building, and own your tech journey like a true sysadmin!**  
ğŸš€ **Have a great day, the techy way!** ğŸ˜ğŸ§