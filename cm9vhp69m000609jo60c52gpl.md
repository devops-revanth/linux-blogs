---
title: "Chapter 21 : From Boot to Block: Mastering Linux Run levels, Boot Process & Disk Management"
seoTitle: "Mastering Linux Run Levels and Disk Management"
seoDescription: "Master the Linux boot process, run levels, and disk management in this interactive guide. Enhance your system control and troubleshooting skills"
datePublished: Thu Apr 24 2025 15:00:30 GMT+0000 (Coordinated Universal Time)
cuid: cm9vhp69m000609jo60c52gpl
slug: mastering-linux-run-levels-boot-process-and-disk-management
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1745506769373/e739217a-846e-48de-9b3a-58b7e7cd3693.png
ogImage: https://cdn.hashnode.com/res/hashnode/image/upload/v1745506809350/f031780c-cce3-4b7e-b101-0d4acfa62b02.png

---

## ğŸ”¥ **Introduction: Why Every Linux Admin Must Master the Core**

Whether you're deploying enterprise applications, managing servers in the cloud, or simply trying to troubleshoot a stubborn boot error â€” **understanding how Linux boots, runs, and manages storage is your foundation.**

ğŸ§  Ever wondered:

* *Why did the system boot into emergency mode?*
    
* *What exactly is systemd doing during startup?*
    
* *How do I know if a new disk has been detected or not?*
    
* *Whatâ€™s the best way to manage disks and partitions efficiently?*
    
* *How can I control what users see when they log in?*
    

You're in the right place.

In this blog, we take an **interactive, practical deep dive** into:

* **System Run Levels**: Know what happens at every mode from shutdown to GUI.
    
* **The Linux Boot Process**: Step-by-step journey from BIOS to your login shell.
    
* **Disk Partitioning & Storage Types**: Master tools like `fdisk`, `df`, and `lsblk`.
    
* **Detecting and Managing New Disks**: Live troubleshooting + real commands.
    
* **Customizing the Message of the Day**: Make your logins informative and personal.
    

Whether you're preparing for an RHCSA/RHCE exam, building your home lab, or managing production systems â€” this guide equips you with the **clarity and commands** you need to feel at home in any Linux environment.

### ğŸ§­ **System Run Levels in Linux**

#### ğŸŸ¨ **Why?**

Understanding Linux run levels is critical for system admins to control how the system boots and what services get initialized. Itâ€™s especially useful for recovery, maintenance, or switching between CLI and GUI modes.

#### ğŸŸ¦ **What?**

A **run level** defines a state of the machine based on the services that are running. These run levels are a legacy concept from SysVinit but still influence how `systemd` handles targets in modern distros like RHEL/CentOS 7+.

Hereâ€™s a quick rundown of traditional run levels:

| Run Level | Description |
| --- | --- |
| 0 | Halt/shutdown the system |
| 1 | Single-user mode (rescue/maintenance mode) |
| 2 | Multiuser, no networking |
| 3 | Multiuser with networking (CLI only) |
| 5 | Multiuser with networking and GUI |
| 6 | Reboot the system |

In **systemd**, these are mapped to targets like:

* [`runlevel3.target`](http://runlevel3.target) = [`multi-user.target`](http://multi-user.target)
    
* [`runlevel5.target`](http://runlevel5.target) = [`graphical.target`](http://graphical.target)
    

#### ğŸŸ© **How?**

ğŸ‘‰ To check the current run level:

```bash
runlevel
```

ğŸ‘‰ To change the default run level (target in systemd):

```bash
systemctl get-default
systemctl set-default multi-user.target   # for runlevel 3
systemctl set-default graphical.target    # for runlevel 5
```

ğŸ‘‰ To switch to a different target immediately:

```bash
systemctl isolate multi-user.target
```

ğŸ” **Real-world use case:** You're working on a server without need for GUI. You save resources by setting the system to boot into [**multi-user.target**](http://multi-user.target) instead of [**graphical.target**](http://graphical.target).

---

## ğŸš€ **Understanding the Linux Boot Process (The Road to a Running System)**

---

### ğŸŸ¨ **Why should you care?**

Ever seen a Linux machine stuck at boot with cryptic messages on screen? Or ever needed to change which kernel to boot from? These moments test a Linux adminâ€™s skill.

Knowing **how Linux boots**â€”step by stepâ€”helps you **troubleshoot system failures**, **tune performance**, and even **customize system behavior** (like selecting a different runlevel or adding a splash screen). Since **RHEL/CentOS 7**, the game changed with the introduction of `systemd`.

Letâ€™s dive into the **modern boot sequence**, interactively.

---

### ğŸŸ¦ **What really happens when you power on a Linux system?**

Letâ€™s take a trip from the press of the power button to the familiar login prompt.

---

ğŸ‘¨â€ğŸ’» **Step 1: BIOS/UEFI kicks in**

When you hit that power button, the **BIOS** (or **UEFI** on modern machines) starts the party.  
Think of BIOS as the old-school host checking your hardware:  
âœ… CPU is ready?  
âœ… RAM looks fine?  
âœ… Keyboard, drives, etc. are connected?

It runs **POST** (Power-On Self Test) and once happy, it hands over control to the bootloader.  
If UEFI is in use, it goes to the **EFI system partition** instead.

---

ğŸ§± **Step 2: MBR or EFI points to GRUB2**

Once the hardware checks are done, the BIOS looks to the **first sector of your hard drive**â€”the **MBR (Master Boot Record)** or **EFI partition**â€”for instructions.

This is where **GRUB2** (our boot manager) lives.

---

ğŸŒ€ **Step 3: GRUB2 loads up**

Now, GRUB2 takes the wheel. It:

* Displays that menu where you can choose which kernel or OS to boot (useful for recovery!)
    
* Reads its configuration file:
    
    ```bash
    /boot/grub2/grub.cfg
    ```
    
* Loads the **Linux kernel** and the **initramfs (initial RAM disk)**
    

Want to change the default boot entry? You edit `grub.cfg` or `/etc/default/grub`.

---

ğŸ§  **Step 4: Kernel time!**

Once GRUB2 gives the green light, the **Linux kernel** is loaded into memory.  
Itâ€™s the brain of Linuxâ€”initializing your CPU, memory, file systems, and device drivers.

But the kernel canâ€™t handle everything alone yet. Thatâ€™s where...

---

ğŸ“¦ **Step 5: initramfs/initrd comes in**

The **initramfs** is a compressed archive of essential drivers and tools. It:

* Mounts the real root filesystem
    
* Gets the system ready to transition into full-blown Linux mode
    

It's like a temporary skeleton to get the full body running.

---

âš™ï¸ **Step 6: Hello, systemd (PID 1)**

Now the real fun begins.

The **first process** the kernel starts is `systemd`, and it gets **PID 1**. Thatâ€™s your **master process**â€”the new age replacement for the old `init`.

`systemd` checks:

```bash
/etc/systemd/system/default.target
```

This file determines **what state (target)** the system should boot intoâ€”whether it's:

* Multi-user with networking ([`multi-user.target`](http://multi-user.target))
    
* Graphical interface ([`graphical.target`](http://graphical.target))
    
* Rescue or emergency modes for debugging
    

It also **starts all services**, mounts file systems, and sets up your login.

---

### ğŸŸ© **How do you interact with and troubleshoot the boot process?**

Here are some super practical commands youâ€™ll use as a sysadmin:

ğŸ” **Check your current boot target**:

```bash
systemctl get-default
```

ğŸ” **Change to text-only mode (good for servers)**:

```bash
systemctl set-default multi-user.target
```

ğŸ’¡ **Analyze slow boots**:

```bash
systemd-analyze
systemd-analyze blame
```

ğŸ›  **Recover from broken service boot failures**: Boot into GRUB â†’ edit the boot line â†’ add:

```bash
systemd.unit=rescue.target
```

ğŸ” **View full boot logs**:

```bash
journalctl -b
```

---

### ğŸ“Œ Real-world Example

You just updated the kernel on a production server. On reboot, it fails and youâ€™re staring at a GRUB prompt.

ğŸ”§ What do you do?

* Select an older working kernel in the GRUB menu
    
* Boot into it
    
* Investigate logs:
    
    ```bash
    journalctl -b -1
    ```
    
* Fix configs or update initramfs if needed:
    
    ```bash
    dracut -f
    ```
    

Reboot. Youâ€™ve just **saved downtime** and earned sysadmin brownie points ğŸ…

---

## ğŸ’¬ **Message of the Day (MOTD) â€“ Welcoming Users Like a Pro**

---

### ğŸŸ¨ **Why does the Message of the Day (MOTD) matter?**

Ever SSH into a system and get greeted with something like:

```bash
Welcome to production-server-1!
Todayâ€™s system load is light. Have a productive day.
```

Thatâ€™s the **Message of the Day**, and itâ€™s more than just decoration. It's your **first chance to communicate with users**, admins, or teammates logging into your server. MOTD can:

* Show **system status**, updates, or alerts
    
* Warn users about **maintenance windows**
    
* Display fun or inspirational messages (hey, weâ€™re human too ğŸ˜„)
    

A well-set MOTD can make your system feel more **professional, personal, and secure**.

---

### ğŸŸ¦ **What is MOTD and where is it stored?**

MOTD stands for **Message of the Day**, and itâ€™s simply a **text file** thatâ€™s displayed when a user logs in via the terminal or over SSH.

Default location:

```bash
/etc/motd
```

However, it can also be **dynamically generated** using scripts in:

```bash
/etc/profile.d/
```

---

### ğŸŸ© **How do you set a custom MOTD?**

Hereâ€™s how to give your Linux system a custom welcome screen ğŸ‘‡

---

#### ğŸ›  Step-by-step to set a static MOTD

ğŸ“ Edit the default MOTD file:

```bash
sudo nano /etc/motd
```

ğŸ”¡ Add your message:

```bash
ğŸš€ Welcome to Durgarevu's Dev Server ğŸš€
ğŸ“ Uptime: $(uptime -p)
ğŸ’¾ Memory Free: $(free -h | grep Mem | awk '{print $4}')
```

ğŸ’¡ Note: Static MOTD doesn't execute shell commands. For dynamic content, use a script instead (next step).

---

#### âš™ï¸ Set a dynamic MOTD using a shell script

1. **Create a new script** in the `/etc/profile.d/` directory:
    

```bash
sudo nano /etc/profile.d/motd.sh
```

2. **Add your dynamic message content:**
    

```bash
#!/bin/bash
echo ""
echo "ğŸŒ Server Name: $(hostname)"
echo "ğŸ• Time: $(date)"
echo "ğŸ’¡ Tip: Stay curious and keep learning!"
```

3. **Make it executable:**
    

```bash
sudo chmod +x /etc/profile.d/motd.sh
```

---

#### ğŸ” Avoid duplicated MOTD when using SSH

By default, SSH prints `/etc/motd`, but so do login shells. To avoid duplication:

* Edit your SSH config:
    

```bash
sudo nano /etc/ssh/sshd_config
```

* Find and change:
    

```bash
#PrintMotd yes
```

to:

```bash
PrintMotd no
```

* Restart the SSH service:
    

```bash
sudo systemctl restart sshd.service
```

---

### ğŸ§ª Real-World Example

Letâ€™s say you manage 20 developers who use SSH daily on a dev server. You want to remind them of a **code freeze every Friday**.

Set this in your dynamic MOTD script:

```bash
echo "âš ï¸ Reminder: Code Freeze Every Friday at 4 PM. No pushes after that!"
```

Now every developer sees it *before* they start pushing code. No more excuses ğŸ˜

---

## ğŸ’½ **Disk Partitioning â€“ Slicing Your Storage Like a Pro ğŸ°**

---

### ğŸŸ¨ **Why do we need disk partitioning?**

Imagine you're hosting multiple servicesâ€”web, database, logsâ€”on a single server. Without proper **disk partitioning**, one misbehaving service could hog all the space and crash your system. Not fun.

Partitioning helps you:

* Organize data **logically** (e.g., `/home`, `/var`, `/opt`)
    
* **Prevent one directory** from consuming all space
    
* Improve **security** and **backup** strategies
    
* Set **quotas** and fine-tune **I/O performance**
    

Simply put, partitioning gives you **control and structure**â€”especially useful for sysadmins and DevOps folks managing real-world Linux servers.

---

### ğŸŸ¦ **What is disk partitioning in Linux?**

Partitioning is the act of **dividing a hard drive** into distinct regions that the OS can manage separately. Each partition behaves like an independent disk.

Typical Linux partitions include:

* `/` (root): Where your OS lives
    
* `/home`: Users' files
    
* `/var`: Logs, mail, and frequently changing data
    
* `/boot`: Kernel and boot files
    
* `swap`: Virtual memory
    

Partitions are created at install time, but can also be added/modified later using tools like `fdisk` or `parted`.

---

### ğŸŸ© **How to view and create partitions in Linux?**

Letâ€™s walk through **viewing and creating a partition** on a brand new disk.

---

#### ğŸ” View existing partitions

```bash
df -h      # Shows mounted filesystems with size
lsblk      # Shows block devices in a tree-like view
sudo fdisk -l   # Shows all partition tables and details
```

Example output:

```bash
Disk /dev/sda: 100 GB
/dev/sda1  *   512MB  Linux boot
/dev/sda2       80GB  Linux LVM
```

---

#### ğŸ› ï¸ Create a new partition using `fdisk`

Letâ€™s say you've attached a new disk `/dev/sdb`.

1. Open the disk for partitioning:
    

```bash
sudo fdisk /dev/sdb
```

2. Enter interactive mode:
    

```bash
n   # New partition
p   # Primary
1   # Partition number
<Enter>   # Default start
+10G      # Size of the partition
```

3. Write and exit:
    

```bash
w   # Write changes to disk
```

4. Format the new partition:
    

```bash
sudo mkfs.ext4 /dev/sdb1
```

5. Mount it:
    

```bash
sudo mkdir /data
sudo mount /dev/sdb1 /data
```

6. Make it permanent by editing `/etc/fstab`:
    

```bash
/dev/sdb1    /data    ext4    defaults    0 2
```

---

### ğŸ§ª Real-World Example: Hosting a Large App

Youâ€™re deploying a Java-based app that logs heavily into `/opt/app/logs`. Instead of storing logs on `/` (which could fill up fast), you create a **dedicated 20GB partition mounted at** `/opt/app/logs`. This isolates logs and avoids root filesystem overflows.

ğŸ’¡ Pro Tip: Use LVM (Logical Volume Manager) if you want more flexibility (e.g., resizing partitions on the fly).

---

## ğŸ§© **Adding Disks in Linux â€“ Expand Your Storage Like a Pro**

---

### ğŸŸ¨ **Why would you want to scan and add a new disk?**

Adding a new disk isnâ€™t always as simple as plugging it in and seeing it appear.

In the real world (especially in VMs or SAN environments), you might:

* Attach a disk in the **hypervisor (like VMware or KVM)**, but the OS doesnâ€™t see it yet.
    
* Replace or add a disk in a **cloud VM**, and Linux doesnâ€™t pick it up automatically.
    
* Use **storage arrays or external devices**, which often require manual scanning.
    

So... you **scan the SCSI bus** to tell Linux:  
"Hey buddy, check again â€” I added new hardware!"

---

### ğŸŸ¦ **What happens when you scan for new disks?**

Linux communicates with the **SCSI subsystem** to detect any changes in the disk landscape.  
This forces a **re-scan of connected devices**, allowing Linux to detect new block devices like `/dev/sdb`, `/dev/sdc`, etc.

---

### ğŸŸ© **How to scan and add a new disk (the full process)?**

Letâ€™s go full pro-level here â€” with disk scanning included.

---

#### ğŸ”¹ Step 0: Scan for newly added disks

Before anything else, **rescan the SCSI host(s)**:

```bash
# List SCSI hosts
ls /sys/class/scsi_host/
```

You might see:

```bash
host0  host1  host2
```

Now tell each host to rescan:

```bash
for host in /sys/class/scsi_host/host*; do
  echo "- - -" | sudo tee $host/scan
done
```

This prompts Linux to check for any newly attached storage.

---

#### ğŸ”¹ Step 1: List block devices

Check what's been discovered:

```bash
lsblk
```

New disks usually appear as `/dev/sdb`, `/dev/sdc`, etc.

---

#### ğŸ”¹ Step 2: Partition the disk

```bash
sudo fdisk /dev/sdc
```

Inside the `fdisk` prompt:

```bash
n     # New partition
p     # Primary
1     # Partition number
<Enter>   # Default start sector
+10G      # Size (example)
w         # Write and exit
```

---

#### ğŸ”¹ Step 3: Format the partition

```bash
sudo mkfs.ext4 /dev/sdc1
```

You can also use `xfs`, `btrfs`, or others depending on your needs.

---

#### ğŸ”¹ Step 4: Create a mount point

```bash
sudo mkdir /mnt/data
```

---

#### ğŸ”¹ Step 5: Mount the partition

```bash
sudo mount /dev/sdc1 /mnt/data
```

---

#### ğŸ”¹ Step 6: Make the mount persistent (add to `/etc/fstab`)

```bash
echo '/dev/sdc1 /mnt/data ext4 defaults 0 0' | sudo tee -a /etc/fstab
```

Now it will auto-mount on boot.

---

### ğŸ§ª Real-World Use Case: Scaling Up Web Servers

You're running a **LAMP stack** on a cloud VM. Your `/var/www` is running out of space as your site content grows.  
So, you add a new 50GB virtual disk in your cloud portal.

â¡ï¸ You scan for new devices  
â¡ï¸ Partition and format the disk  
â¡ï¸ Mount it to `/var/www/html`

ğŸ‰ No downtime. Your site gets room to breathe â€” and grow.

---

ğŸ’¡ **Bonus Tips**:

* Use `lsblk`, `blkid`, and `partprobe` to verify and refresh partition tables.
    
* Consider `LVM` or `RAID` if managing multiple disks or needing flexibility.
    
* Always backup `/etc/fstab` before editing!
    

---

## ğŸ§© **Conclusion: Mastering Linux System Foundations**

As a Linux administrator, understanding the foundational components of your system is non-negotiable â€” itâ€™s what separates a reactive operator from a proactive engineer.

In this blog, you explored:

âœ… **System Run Levels** â€“ To control how your system boots and behaves in different modes  
âœ… **The Boot Process** â€“ From BIOS to systemd, you now know every stop on the startup train  
âœ… **Disk Partitioning & Management** â€“ Whether expanding storage or optimizing performance  
âœ… **Disk Detection Techniques** â€“ Scanning for new disks like a true sysadmin ninja  
âœ… **Message of the Day (MOTD)** â€“ Adding personalization and clarity to every login

All of this adds up to one powerful message:  
ğŸ’¡ *If you can control how your system boots, behaves, and scales â€” you can control the Linux universe.*